# Docker Environments ğŸŒ

> **Outline**:

- [ ] Introduction to Multi-Environment Setup
- [ ] Why Use Multiple Environments?
- [ ] Creating Docker Compose Files for Each Environment
  - [ ] Base Configuration ğŸ“
  - [ ] Production Setup âš™ï¸
  - [ ] Development Setup ğŸ› ï¸
- [ ] Switching Between Environments
- [ ] Best Practices for Managing Environments ğŸ§‘â€ğŸ’»

---

## How to Run Docker with More than One Environment (Production and Development)?

### 1. Introduction to Multi-Environment Setup ğŸŒŸ

When developing and deploying applications, it's crucial to maintain separate environments for development, testing, and production. This allows developers to experiment in development while ensuring stability in production.

### 2. Why Use Multiple Environments? ğŸ’¡

- **Development**: Allows testing new features without affecting end users.
- **Production**: Stable environment optimized for performance and security.
- **Staging/Testing**: Optional environment to simulate production before deploying changes.

### 3. Creating Docker Compose Files for Each Environment ğŸ“‚

#### Base Configuration (`docker-compose.yml`) ğŸ“„

This file contains the common configurations for your services. It can include shared services like databases.

```yaml
version: "3"
services:
  app:
    image: myapp:latest
    environment:
      - APP_ENV=base
    networks:
      - mynetwork

  db:
    image: postgres:13
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
    networks:
      - mynetwork

networks:
  mynetwork:
```

#### Production Config (`docker-compose.prod.yml`) âš™ï¸

```yaml
version: "3"
services:
  app:
    environment:
      - APP_ENV=production
    ports:
      - "80:80"
    restart: always
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    networks:
      - mynetwork

networks:
  mynetwork:
```

#### Development Config (`docker-compose.dev.yml`) ğŸ› ï¸

```yaml
version: "3"
services:
  app:
    environment:
      - APP_ENV=development
    ports:
      - "8080:80"
    volumes:
      - .:/app
    command: npm run dev
    networks:
      - mynetwork

networks:
  mynetwork:
```

### 4. Switching Between Environments ğŸ”€

You can easily switch between environments by combining the base file with the appropriate environment-specific file.

- **Production**:

  ```bash
  docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d
  ```

- **Development**:
  ```bash
  docker-compose -f docker-compose.yml -f docker-compose.dev.yml up -d
  ```

These commands override the base configurations with environment-specific settings.

### 5. Practical Example ğŸ§‘â€ğŸ’»

Hereâ€™s a scenario to show how you can switch between environments effectively:

| Environment     | Command                                                                 | Description                                                                 |
| --------------- | ----------------------------------------------------------------------- | --------------------------------------------------------------------------- |
| **Production**  | `docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d` | Runs the services with production settings. Ports are mapped to `80:80`.    |
| **Development** | `docker-compose -f docker-compose.yml -f docker-compose.dev.yml up -d`  | Runs the services in development mode. Hot reloading and `8080:80` mapping. |

### 6. Best Practices for Managing Environments ğŸ›¡ï¸

1. **Use `.env` files for secrets** ğŸ”‘  
   Store sensitive information such as database passwords in an `.env` file, which can be referenced in `docker-compose.yml`:

   ```yaml
   environment:
     - POSTGRES_USER=${POSTGRES_USER}
     - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
   ```

2. **Use Version Control for Docker Compose Files** ğŸ“‚  
   Keep separate `docker-compose` files for each environment under version control so they can be reviewed and shared easily among teams.

3. **Use a Staging Environment for Testing** ğŸ“‹  
   Before deploying to production, consider running a staging environment using another Docker Compose file, such as `docker-compose.staging.yml`.

### 7. Visual Overview ğŸŒ

Create a flowchart or diagram to illustrate how Docker uses different Compose files to configure environments. This could show the following steps:

- Docker uses `docker-compose.yml` as the base.
- It applies overrides from environment-specific files like `docker-compose.prod.yml` or `docker-compose.dev.yml`.
- The final container configuration is launched based on the merged setup.

---
